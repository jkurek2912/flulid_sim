<!DOCTYPE html>
<html>
  <head>
    <title>Fluid Simulator</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 20px;
      }

      .button {
        background-color: #4caf50;
        border: none;
        color: white;
        padding: 10px 15px;
        text-align: center;
        font-size: 16px;
        margin: 4px 2px;
        cursor: pointer;
        border-radius: 4px;
      }

      canvas {
        border: 1px solid #000;
        margin-top: 10px;
      }

      .controls {
        margin-bottom: 10px;
      }
    </style>
  </head>
  <body>
    <div class="controls">
      <button class="button" onclick="setupWindTunnel()">Wind Tunnel</button>
      <button class="button" onclick="setupPaintMode()">Paint Mode</button>
      <input
        type="checkbox"
        id="showVelocity"
        onclick="toggleVelocityLines()"
      />Show Velocity
    </div>

    <canvas id="simCanvas"></canvas>

    <script src="sim.js"></script>
    <script>
      // Canvas setup
      const canvas = document.getElementById("simCanvas");
      const ctx = canvas.getContext("2d");

      // Set canvas dimensions
      canvas.width = window.innerWidth - 40;
      canvas.height = window.innerHeight - 100;

      // Simulation settings
      const simHeight = 1.1;
      const cScale = canvas.height / simHeight;
      const simWidth = canvas.width / cScale;

      // Scene state
      const scene = {
        fluid: null,
        showVelocities: false,
        gravity: 0.0,
        dt: 1 / 60,
        numIters: 40,
        overRelaxation: 1.5,
        obstacleX: 0.0,
        obstacleY: 0.0,
        obstacleRadius: 0.1,
        mouseDown: false,
      };

      // Functions to implement:
      // - setupPaintMode()
      // - toggleVelocityLines()
      // - draw()
      // - Mouse/touch event handling

      // Initialize
      function init() {
        setupWindTunnel();
        requestAnimationFrame(update);
      }

      function update() {
        simulate();
        draw();
        requestAnimationFrame(update);
      }

      function setupWindTunnel() {
        // reset params
        scene.gravity = 0.0;
        scene.overRelaxation = 1.5;
        scene.numIters = 40;
        scene.showVelocities = false;

        // set dimensions
        const res = 100;
        const h = simHeight / res;
        const numX = Math.floor(simWidth / h);
        const numY = Math.floor(simHeight / h);

        scene.fluid = new Sim(numX, numY, h);

        const n = scene.fluid.numY;
        const f = scene.fluid;

        // set up boundary conditions for wind tunnel
        for (let i = 0; i < f.numX; i++) {
          for (let j = 0; j < f.numY; j++) {
            // default to fluid
            let s = 1.0;

            // make left, top, and bottom boundaries solid
            if (i == 0 || j == 0 || j == f.numY - 1) {
              s = 0.0;
            }

            f.s[i * n + j] = s;

            // set inlet velocity at the left edge
            if (i == 1) {
              f.u[i * n + j] = 2.0;
            }
          }
        }

        // place obstacle on screen
        placeObstacle(0.4, 0.5, true);

        // reset any UI elements
        document.getElementById("showVelocity").checked = scene.showVelocities;
      }

      // helper function to place obstacle
      function placeObstacle(x, y, reset) {
        let vx = 0.0;
        let vy = 0.0;

        if (!reset) {
          // calculate obstacle velocity if its being moved
          vx = (x - scene.obstacleX) / scene.dt;
          vy = (y - scene.obstacleY) / scene.dt;
        }

        // update position
        scene.obstacleX = x;
        scene.obstacleY = y;

        const r = scene.obstacleRadius;
        const f = scene.fluid;
        const n = f.numY;

        // apply obstacle to fluid grid
        for (let i = 1; i < f.numX - 1; i++) {
          for (let j = 1; j < f.numY - 1; j++) {
            // reset cell to fluid
            f.s[i * n + j] = 1.0;

            // calculate distance to obstacle center
            const dx = (i + 0.5) * f.h - x;
            const dy = (j + 0.5) * f.h - y;

            // if inside obstacle radius, mark solid
            if (dx * dx + dy * dy <= r * r) {
              f.s[i * n + j] = 0.0;

              // add smoke at obstacle for visualization
              f.m[i * n + j] = 1.0;

              // set velocities to match obstacle if its moving
              f.u[i * n + j] = vx;
              f.u[(i + 1) * n + j] = vx;
              f.v[i * n + j] = vy;
              f.v[i * n + j + 1] = vy;
            }
          }
        }
      }

      function draw() {
        // clear canvas
        ctx.clearRect(0, 0, canvasWidth, canvasHeight);

        // if no fluid sim, return
        if (!scene.fluid) return;

        const f = scene.fluid;
        const n = f.numY;
        const h = f.h;

        // draw smoke and density fields
        for (let i = 0; i < f.numX; i++) {
          for (let j = 0; j < f.numY; j++) {
            // skip solid cells
            if (f.s[(i * n, j)] == 0.0) {
              continue;
            }

            // calculate cell center
            const x = i * h;
            const y = j * h;

            // get smoke density
            const density = f.m[i * n + j];

            ctx.globalAlpha = density;
            ctx.fillStyle = "black";

            // draw cell
            ctx.fillRect(
              x * cScale,
              (simHeight - y - h) * cScale,
              h * cScale,
              h * sCale
            );
          }
        }

        // draw obstacle
        if (scene.obstacleX !== 0 || scene.obstacleY !== 0) {
          ctx.globalAlpha = 1;
          ctx.fillStyle = "green";
          ctx.beginPath();
          ctx.arc(
            scene.obstacleX * cScale,
            (simHeight - scene.obstacleY) * cScale,
            scene.obstacleRadius * cScale,
            0,
            Math.PI * 2
          );
        }
      }

      function simulate() {
        // Only simulate if not paused
        if (!scene.paused) {
          scene.fluid.simulate(
            scene.dt, // time step
            scene.gravity, // gravity
            scene.numIters // number of pressure solve iterations
          );

          // Increment frame number
          scene.frameNr++;
        }
      }

      init();
    </script>
  </body>
</html>
